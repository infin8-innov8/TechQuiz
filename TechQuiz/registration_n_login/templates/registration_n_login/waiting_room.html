<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TIC Tech Quiz - Waiting Room</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@500;700&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            position: fixed;
            background-color: #0a0e27;
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .bubbler-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #0f1629 100%);
        }

        .bubbler-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
            touch-action: none;
        }

        .bubbler-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .bubbler-header {
            text-align: center;
            padding: 3rem 2rem;
            background: linear-gradient(180deg, rgba(10, 14, 39, 0.95) 0%, rgba(10, 14, 39, 0) 100%);
        }

        .bubbler-title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(2rem, 5vw, 2.5rem);
            font-weight: 900;
            background: linear-gradient(135deg, #00f5ff 0%, #00d4ff 50%, #0099ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 30px rgba(0, 245, 255, 0.3);
            animation: glow-pulse 3s ease-in-out infinite;
        }

        .bubbler-subtitle {
            font-family: 'Inter', sans-serif;
            font-size: clamp(1rem, 3vw, 1.2rem);
            color: rgba(255, 255, 255, 0.7);
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .bubbler-footer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: clamp(1rem, 3vw, 2rem);
            text-align: center;
            background: linear-gradient(0deg, rgba(10, 14, 39, 0.95) 0%, rgba(10, 14, 39, 0) 100%);
        }

        .bubbler-instruction {
            font-family: 'Inter', sans-serif;
            font-size: clamp(0.9rem, 2vw, 1rem);
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 1rem;
            animation: fade-in-out 2s ease-in-out infinite;
        }

        .bubbler-stats {
            display: flex;
            justify-content: center;
            gap: clamp(1rem, 4vw, 3rem);
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .stat-item {
            font-family: 'Orbitron', sans-serif;
            min-width: 80px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: clamp(1.5rem, 4vw, 2rem);
            font-weight: 700;
            background: linear-gradient(135deg, #00f5ff 0%, #00d4ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        @keyframes glow-pulse {

            0%,
            100% {
                filter: drop-shadow(0 0 20px rgba(0, 245, 255, 0.4));
            }

            50% {
                filter: drop-shadow(0 0 40px rgba(0, 245, 255, 0.8));
            }
        }

        @keyframes fade-in-out {

            0%,
            100% {
                opacity: 0.4;
            }

            50% {
                opacity: 1;
            }
        }

        /* Copyright Footer */
        .copyright-footer {
            margin-top: clamp(1rem, 2vw, 2rem);
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.75rem;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .copyright-footer strong {
            color: #00f5ff;
            font-weight: 600;
        }

        /* Round Starting Notification Modal */
        .notification-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .notification-modal.hidden {
            display: none;
        }

        .notification-content {
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            color: #00f5ff;
            animation: zoomIn 0.5s ease;
            padding: 2rem;
        }

        .notification-content h2 {
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            margin-bottom: 1rem;
            text-shadow: 0 0 20px #00f5ff;
        }

        .notification-content p {
            font-size: clamp(1rem, 3vw, 1.2rem);
            color: #fff;
            margin-bottom: 2rem;
        }

        .countdown {
            font-size: clamp(3rem, 10vw, 5rem);
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 30px #9333ea;
            font-family: 'Orbitron', sans-serif;
        }

        @keyframes zoomIn {
            from {
                transform: scale(0.5);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Mobile-specific optimizations */
        @media (max-width: 768px) {
            .bubbler-header {
                padding: 2rem 1rem;
            }

            .stat-item {
                min-width: 70px;
            }

            .stat-value {
                font-size: 1.5rem;
            }
        }

        /* Small mobile devices */
        @media (max-width: 480px) {
            .bubbler-title {
                font-size: 1.8rem;
            }

            .bubbler-subtitle {
                font-size: 0.9rem;
                letter-spacing: 1px;
            }

            .bubbler-stats {
                gap: 1.5rem;
            }

            .stat-item {
                min-width: 65px;
            }

            .stat-value {
                font-size: 1.3rem;
            }

            .bubbler-instruction {
                font-size: 0.8rem;
            }
        }

        /* Very small devices */
        @media (max-width: 360px) {
            .bubbler-stats {
                gap: 1rem;
            }

            .stat-item {
                min-width: 60px;
            }

            .stat-value {
                font-size: 1.2rem;
            }
        }

        /* Landscape mode */
        @media (orientation: landscape) and (max-height: 500px) {
            .bubbler-header {
                padding: 1rem;
            }

            .bubbler-title {
                font-size: 1.5rem;
                margin-bottom: 0.25rem;
            }

            .bubbler-subtitle {
                font-size: 0.8rem;
            }

            .bubbler-footer {
                padding: 0.5rem;
            }

            .bubbler-instruction {
                margin-bottom: 0.5rem;
                font-size: 0.7rem;
            }

            .bubbler-stats {
                margin-top: 0.5rem;
            }

            .stat-item {
                min-width: 50px;
            }

            .stat-value {
                font-size: 1.2rem;
            }

            .copyright-footer {
                margin-top: 0.5rem;
                font-size: 0.6rem;
            }
        }
    </style>
</head>

<body>
    <div class="bubbler-container">
        <canvas class="bubbler-canvas" id="bubbler-canvas"></canvas>

        <div class="bubbler-overlay">
            <div class="bubbler-header">
                <h1 class="bubbler-title">Best of Luck</h1>
                <div class="bubbler-subtitle">Round Starting Soon</div>
            </div>

            <div class="bubbler-footer">
                <div class="bubbler-instruction">
                    ✨ Tap anywhere to create bubbles ✨
                </div>
                <div class="bubbler-stats">
                    <div class="stat-item">
                        <div class="stat-label">Bubbles</div>
                        <div class="stat-value" id="bubble-count">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Popped</div>
                        <div class="stat-value" id="popped-count">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Score</div>
                        <div class="stat-value" id="score-count">0</div>
                    </div>
                </div>

                <div class="copyright-footer">
                    @developed by <strong>TIC</strong> | Department of Technology
                </div>
            </div>
        </div>
    </div>

    <!-- Round Starting Notification Modal -->
    <div class="notification-modal hidden" id="round-start-modal">
        <div class="notification-content">
            <h2 id="round-title">Round 1 Starting!</h2>
            <p>Give your best!</p>
            <div class="countdown" id="countdown">5</div>
        </div>
    </div>

    <script>
        // Prevent default touch behaviors
        document.addEventListener('touchmove', function (e) {
            if (e.scale !== 1) { e.preventDefault(); }
        }, { passive: false });

        document.addEventListener('touchstart', function (e) {
            if (e.touches.length > 1) { e.preventDefault(); }
        }, { passive: false });

        // Game Status Polling
        let isRedirecting = false;

        async function checkGameStatus() {
            if (isRedirecting) return;

            try {
                const response = await fetch('/api/game/status/');
                const data = await response.json();

                if (data.round_status === 'ONGOING' && data.active_round === 1) {
                    if (!data.is_submitted) {
                        startRedirectSequence(1);
                    }
                } else if (data.round_status === 'ONGOING' && data.active_round === 2) {
                    if (!data.is_submitted) {
                        if (data.is_qualified) {
                            startRedirectSequence(2);
                        } else {
                            window.location.href = `/eliminated/?score=${data.last_score}&rank=${data.rank}&total=${data.total_score}&round=1&team=${encodeURIComponent(data.team_name || '')}`;
                        }
                    }
                } else if (data.round_status === 'ONGOING' && data.active_round === 3) {
                    if (data.is_qualified) {
                        window.location.href = '/round-3/';
                    } else {
                        window.location.href = `/eliminated/?score=${data.last_score}&rank=${data.rank}&total=${data.total_score}&round=2&team=${encodeURIComponent(data.team_name || '')}`;
                    }
                }
            } catch (error) {
                console.error("Polling error:", error);
            }
        }

        function startRedirectSequence(round) {
            isRedirecting = true;
            const modal = document.getElementById('round-start-modal');
            const title = document.getElementById('round-title');
            const countdownEl = document.getElementById('countdown');

            title.textContent = `Round ${round} Starting!`;
            modal.classList.remove('hidden');

            let count = 5;
            countdownEl.textContent = count;

            const interval = setInterval(() => {
                count--;
                countdownEl.textContent = count;
                if (count <= 0) {
                    clearInterval(interval);
                    window.location.href = `/round-${round}/`;
                }
            }, 1000);
        }

        // Canvas setup
        const canvas = document.getElementById('bubbler-canvas');
        const ctx = canvas.getContext('2d');

        // Detect if mobile
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

        // Track canvas dimensions
        let canvasWidth = 0;
        let canvasHeight = 0;

        // Proper canvas resizing for mobile
        function resizeCanvas() {
            // Use window's inner dimensions
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;

            // Set canvas display size
            canvas.style.width = canvasWidth + 'px';
            canvas.style.height = canvasHeight + 'px';

            // Set canvas internal size (for drawing)
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            console.log('Canvas resized to:', canvasWidth, 'x', canvasHeight);
        }

        // Initial resize
        resizeCanvas();

        // Handle orientation changes and resizes properly
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resizeCanvas();
                // Re-position existing bubbles if needed
                bubbles.forEach(bubble => {
                    if (bubble.x > canvasWidth) bubble.x = canvasWidth - bubble.radius;
                    if (bubble.y > canvasHeight) bubble.y = canvasHeight - bubble.radius;
                });
            }, 100);
        });

        // Handle orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });

        // Fix for iOS Safari 100vh issue
        function fixIOSHeight() {
            if (isMobile) {
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
            }
        }

        fixIOSHeight();
        window.addEventListener('resize', fixIOSHeight);

        // Stats
        let stats = {
            bubbleCount: 0,
            poppedCount: 0,
            score: 0
        };

        // Bubble class
        class Bubble {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 40 + 20;
                this.maxRadius = this.radius;
                this.speedY = -(Math.random() * 0.8 + 0.4);
                this.speedX = (Math.random() - 0.5) * 0.8;
                this.opacity = 1;
                this.hue = Math.random() * 60 + 180;
                this.wobble = Math.random() * Math.PI * 2;
                this.wobbleSpeed = Math.random() * 0.03 + 0.01;
                this.growing = true;
                this.growthRate = 0.5;
                this.popped = false;
                this.popAnimation = 0;
                this.glowIntensity = Math.random() * 0.5 + 0.5;
                this.createdAt = Date.now();
                this.lifespan = 15000; // 15 seconds max
            }

            update() {
                // Auto-fade after lifespan
                if (Date.now() - this.createdAt > this.lifespan) {
                    this.opacity -= 0.01;
                }

                if (this.popped) {
                    this.popAnimation += 0.15;
                    this.radius += 3;
                    this.opacity -= 0.08;
                    return this.opacity > 0;
                }

                if (this.growing) {
                    this.radius += this.growthRate;
                    if (this.radius >= this.maxRadius) {
                        this.growing = false;
                    }
                }

                this.y += this.speedY;
                this.x += this.speedX + Math.sin(this.wobble) * 0.5;
                this.wobble += this.wobbleSpeed;

                // Fade out as it rises
                if (this.y < canvasHeight * 0.3) {
                    this.opacity -= 0.005;
                }

                // Boundary check with bounce
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.speedX *= -0.8;
                }
                if (this.x + this.radius > canvasWidth) {
                    this.x = canvasWidth - this.radius;
                    this.speedX *= -0.8;
                }

                return this.opacity > 0 && this.y + this.radius > -50;
            }

            draw() {
                ctx.save();

                if (this.popped) {
                    // Pop effect
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `hsla(${this.hue}, 100%, 70%, ${this.opacity})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Particles
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 * i) / 8;
                        const dist = this.popAnimation * 20;
                        const px = this.x + Math.cos(angle) * dist;
                        const py = this.y + Math.sin(angle) * dist;
                        ctx.beginPath();
                        ctx.arc(px, py, 3, 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${this.opacity})`;
                        ctx.fill();
                    }
                } else {
                    // Outer glow
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.radius * 1.5
                    );
                    gradient.addColorStop(0, `hsla(${this.hue}, 100%, 70%, ${this.opacity * 0.3 * this.glowIntensity})`);
                    gradient.addColorStop(0.5, `hsla(${this.hue}, 100%, 60%, ${this.opacity * 0.1 * this.glowIntensity})`);
                    gradient.addColorStop(1, `hsla(${this.hue}, 100%, 50%, 0)`);

                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    // Main bubble
                    const bubbleGradient = ctx.createRadialGradient(
                        this.x - this.radius * 0.3, this.y - this.radius * 0.3, 0,
                        this.x, this.y, this.radius
                    );
                    bubbleGradient.addColorStop(0, `hsla(${this.hue}, 100%, 80%, ${this.opacity * 0.8})`);
                    bubbleGradient.addColorStop(0.4, `hsla(${this.hue}, 100%, 60%, ${this.opacity * 0.5})`);
                    bubbleGradient.addColorStop(1, `hsla(${this.hue}, 100%, 40%, ${this.opacity * 0.3})`);

                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = bubbleGradient;
                    ctx.fill();

                    // Highlight
                    ctx.beginPath();
                    ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity * 0.6})`;
                    ctx.fill();

                    // Rim
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `hsla(${this.hue}, 100%, 90%, ${this.opacity * 0.4})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                ctx.restore();
            }

            isClicked(x, y) {
                const dist = Math.hypot(x - this.x, y - this.y);
                return dist < this.radius;
            }

            pop() {
                if (!this.popped) {
                    this.popped = true;
                    stats.poppedCount++;
                    stats.score += Math.floor(this.maxRadius);
                    updateStats();
                    return true;
                }
                return false;
            }
        }

        // Bubble management
        let bubbles = [];
        let autoSpawnInterval;

        // Create ambient bubbles automatically
        function spawnAmbientBubble() {
            if (bubbles.length < (isMobile ? 20 : 40)) { // Limit bubbles for performance
                const x = Math.random() * canvasWidth;
                const y = canvasHeight + 50;
                const bubble = new Bubble(x, y);
                bubbles.push(bubble);
                stats.bubbleCount++;
                updateStats();
                console.log('Ambient bubble spawned at', x, y);
            }
        }

        // Start ambient spawning with mobile-appropriate intervals
        autoSpawnInterval = setInterval(spawnAmbientBubble, isMobile ? 1000 : 800);

        // Update stats display
        function updateStats() {
            document.getElementById('bubble-count').textContent = stats.bubbleCount;
            document.getElementById('popped-count').textContent = stats.poppedCount;
            document.getElementById('score-count').textContent = stats.score;
        }

        // Handle interaction
        function handleInteraction(x, y, isClick = false) {
            // Get correct coordinates relative to canvas
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (x - rect.left) * scaleX;
            const canvasY = (y - rect.top) * scaleY;

            console.log('Interaction at:', canvasX, canvasY, 'isClick:', isClick);

            // Check if clicked on existing bubble
            let clickedBubble = false;
            for (let i = bubbles.length - 1; i >= 0; i--) {
                if (bubbles[i].isClicked(canvasX, canvasY)) {
                    bubbles[i].pop();
                    clickedBubble = true;
                    console.log('Bubble popped!');
                    break;
                }
            }

            // Create new bubble if not clicked on existing one and it's a click/tap
            if (!clickedBubble && isClick) {
                if (bubbles.length < (isMobile ? 25 : 50)) {
                    const bubble = new Bubble(canvasX, canvasY);
                    bubbles.push(bubble);
                    stats.bubbleCount++;
                    updateStats();
                    console.log('New bubble created at', canvasX, canvasY);
                }
            }
        }

        // Mouse interaction
        canvas.addEventListener('click', (e) => {
            e.preventDefault();
            handleInteraction(e.clientX, e.clientY, true);
        });

        // Touch support for mobile - improved
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleInteraction(touch.clientX, touch.clientY, true);
        }, { passive: false });

        // Background particles
        let particles = [];
        function createParticle() {
            if (particles.length < 50) { // Limit particles
                const particle = {
                    x: Math.random() * canvasWidth,
                    y: canvasHeight,
                    speed: Math.random() * 1 + 0.5,
                    opacity: Math.random() * 0.5 + 0.3,
                    size: Math.random() * 2 + 1
                };
                particles.push(particle);
            }
        }

        setInterval(createParticle, 200);

        // Animation loop with performance optimization
        let animationId;
        let lastTime = 0;

        function animate(timestamp) {
            animationId = requestAnimationFrame(animate);

            // Throttle animation for mobile
            if (isMobile && timestamp - lastTime < 16) return; // ~60fps
            lastTime = timestamp;

            // Clear with slight trail effect
            ctx.fillStyle = 'rgba(10, 14, 39, 0.1)';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Update and draw particles
            particles = particles.filter(p => {
                p.y -= p.speed;
                p.x += Math.sin(p.y * 0.01) * 0.5;

                ctx.fillStyle = `rgba(0, 245, 255, ${p.opacity})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();

                return p.y > -10;
            });

            // Update and draw bubbles
            const before = bubbles.length;
            bubbles = bubbles.filter(bubble => {
                const alive = bubble.update();
                if (alive) bubble.draw();
                return alive;
            });

            // Log if bubbles were removed
            if (bubbles.length < before) {
                console.log(`${before - bubbles.length} bubbles removed`);
            }
        }

        // Start animation
        animate();

        // Initial ambient bubbles
        for (let i = 0; i < 5; i++) {
            setTimeout(spawnAmbientBubble, i * 300);
        }

        // Start game status polling
        checkGameStatus();
        setInterval(checkGameStatus, 3000);

        // Cleanup on page hide
        window.addEventListener('pagehide', () => {
            cancelAnimationFrame(animationId);
            clearInterval(autoSpawnInterval);
        });

        // Log for debugging
        console.log('Bubbler initialized. Mobile:', isMobile);
        console.log('Canvas size:', canvasWidth, 'x', canvasHeight);
    </script>
</body>

</html>